#!/usr/bin/tclsh

set libtcldir [file join [file dirname [file dirname [file normalize [info script]]]] recorder libtcl]
source [file join $libtcldir common.tcl]
source [file join $libtcldir install.tcl]
package require tdbc
package require tdbc::postgres

proc main {} {
    getOptions [configDictFile dispatcher] {}
    set ::config [readDict $::opt(-config)]
    set ::database [dictGetOr talkrec $::config database]
    set ::irConfig [readDict [configDictFile install-recorder]]
    if {[catch {dict get $::irConfig serverAddr} ::serverAddr]} {
	error "В [configDictFile install-recorder] не указан serverAddr"
    }
    array set ::hostState {}
    array set ::hostVersion {}
    asyncLoop runHostChecks 60000 runHostChecks
    after 8000 {asyncLoop fixHostCheckResults 60000 fixHostCheckResults}
    socket -server acceptConfigRequest 17120
    vwait exit
}

proc runHostChecks {} {
    safelog {info "runHostChecks heartbeat"}
    ::tdbc::postgres::connection create dbc -database $::database
    try {
	set hosts [lmap row [dbc allrows -as lists {select ip from record_station}] {lindex $row 0}]
    } finally {dbc close}
    foreach host $hosts {asyncConnect $host 17119 2000 recorder onConnectToRecorder onDisconnectFromRecorder}
}

proc onConnectToRecorder {connData} {
    safelog {debug [list onConnectToRecorder $connData]}
    set chan [dict get $connData chan]
    if {[chanHasError $chan err]} {return [asyncDisconnect $connData error $err]}
    fconfigure $chan -buffering line
    after 4000 [list asyncDisconnect $connData replyTimeout]
    catchDbg {puts $chan [versionRequest]}
    fileevent $chan readable [list onReplyFromRecorder $connData]
}

proc recordError {connData message} {
    if {[catch {dict get $connData host} host]} {
	safelog {error "Нет ключа host в [list $connData]\n  +проблема: $message"}
    } else {
	recordState $host $message
    }
}

proc fixHostCheckResults {} {
    safelog {info "fixHostCheckResults heartbeat"}
    set states [array get ::hostState]
    set versions [array get ::hostVersion]
    array set ::hostState {}
    array set ::hostVersion {}
    if {[dict size $states] + [dict size $versions] == 0} return
    ::tdbc::postgres::connection create dbf -database $::database
    try {
	dict for {host state} $states {
	    foreach {message seconds} $state break
	    set timestamp [clock format $seconds -format "%Y-%m-%d %H:%M:%S%z"]
	    dbf allrows {update record_station set state = :message, state_at = :timestamp where ip = :host and (state <> 'отключен' or state is null)} [dict create message $message timestamp $timestamp host $host]
	}
	dict for {host vd} $versions {
	    dict set vd host $host
	    dbf allrows {update record_station set version = :version, time_diff = :timeDiff where ip = :host} $vd
	}
    } finally {dbf close}
}

proc recordState {host message} {
    set ::hostState($host) [list $message [clock seconds]]
}

proc recordVersion {host vdict} {
    if {[catch {dict get $vdict version} version]} {set version ""}
    if {$version eq ""} {set version "доисторическая"}
    set vd [dict create version $version]
    if {[dict exists $vdict now]} {
	dict set vd timeDiff [expr {[dict get $vdict now] - [clock seconds]}]
    }
    set ::hostVersion($host) $vd
}

proc onDisconnectFromRecorder {connData reason message} {
    safelog {debug [list onDisconnectFromRecorder $connData $reason $message]}
    switch $reason {
	connectTimeout {recordError $connData "недоступна"}
	replyTimeout {recordError $connData "не ответила"}
	error {
	    if {$message eq "connection refused"} {
		recordError $connData "не работает"
	    } else {
		recordError $connData $message
	    }
	}
	ok {
	    if {[catch {dict get $connData host} host]} {
		safelog {error "Нет ключа host в [list $connData]"}
	    } else {
		safelog {debug "$host [list $message]"}
		recordVersion $host $message
		recordState $host "работает"
	    }
	}
	default {recordError $connData $message}
    }
}

proc onReplyFromRecorder {connData} {
    after cancel [list asyncDisconnect $connData replyTimeout]
    try {
	set chan [dict get $connData chan]
	if {[chanHasError $chan err]} {return [asyncDisconnect $connData error $err]}
	while (1) {
	    if {[catch {gets $chan line} len]} {return [asyncDisconnect $connData error $len]}
	    if {$len < 0} break
	    if {[regexp {^\s*$} $line]} continue
	    try {
		set obj [parseObject $line]
		return [asyncDisconnect $connData ok [dict filter $obj key version now]]
	    } on error {err} {
		return [asyncDisconnect $connData ok ""]
	    }
	}
	if {[eof $chan]} {return [asyncDisconnect $connData disconnected "разорвал связь"]}
    } on error {err dbg} {
	debugStackTrace $dbg
	safelog {error "onReplyFromRecorder: $err\n  $connData"}
    }
    after 4000 [list asyncDisconnect $connData replyTimeout]
}

proc versionRequest {} {simpleDictToJSON [dict create msgId [nextMessageId] req version] 0}

proc nextMessageId {} {incr ::nextMessageId}

proc acceptConfigRequest {sock addr port} {
    fconfigure $sock -blocking 0 -buffering line
    after 10000 [list configRequestTimeout $sock $addr $port]
    fileevent $sock readable [list serveConfigRequest $sock $addr $port]
}

proc configRequestTimeout {chan addr port} {
    catch {close $chan}
    safelog {warning "Timeout waiting for config request from $addr"}
}

proc serveConfigRequest {chan addr port} {
    after cancel [list configRequestTimeout $chan $addr $port]
    if {[chanHasError $chan err] || [eof $chan]} {catch {close $chan}; return}
    set line [gets $chan]
    if {$line eq ""} {after 10000 [list configRequestTimeout $chan $addr $port]; return}
    if {[catch {parseObject $line} req]} {
	safelog {error "Непонятный запрос от $addr: $line"}
	catch {close $chan}
	return
    }
    set requestedConfigs [dictGetOr {} $req configurations]
    if {[llength $requestedConfigs] == 0} {catch {close $chan}; return}
    set db [::tdbc::postgres::connection create dbcr -database $::database]
    try {
	if {[catch {dict get [siteAndHeadsetForIP $db $addr] site_id} siteId]} {
	    safelog {error "serveConfigRequest: $siteId"}
	    return
	}
	set reply [dict create]
	foreach cfg $requestedConfigs {
	    switch $cfg {
		employees {dict set reply $cfg [genEmployeesConfig $db $siteId 0]}
		record_manager {dict set reply $cfg [genRecordManagerConfig $db $siteId $::serverAddr 0]}
	    }
	}
	::json::write indented 0
	set replyJson [::json::write object {*}$reply]
	puts $chan $replyJson
    } finally {$db close; catch {close $chan}}
}

runMain
