#!/usr/bin/tclsh

set libtcldir [file join [file dirname [file dirname [file normalize [info script]]]] recorder libtcl]
source [file join $libtcldir common.tcl]

proc main {} {
    getOptions [configFile dispatcher.yaml] {}
    if {![rereadConfig]} {exit 2}
    file mkdir [dict get $::config queue]
    runQueue
    cleanFlagWait
    vwait forever
}

proc rereadConfig {} {
    if {[fileModified $::opt(config)]} {
	if {[catch {readConfig $::opt(config)} err dbg]} {
	    debugStackTrace $dbg
	    ::log::log error "Ошибки при чтении конфигурации из $::opt(config):\n$err"
	    return 0
	}
    }
    return 1
}

proc readConfig {configFile} {
    set defaultConfig [dict create queue ~/queue speechkits [dict create 127.0.0.1:80 1]]
    set readConfig [::yaml::yaml2dict -file $configFile]
    set conf [dict merge $defaultConfig $readConfig]
    set errors {}
    if {[dict size [dict get $conf speechkits]] <= 0} {
	lappend errors "не указан ни один сервер SpeecKit Box (speechkits)"
    }
    if {![dict exists $conf asrclient]} {
	lappend errors "не указан путь к потоковому загрузчику (asrclient)"
    }
    if {[llength $errors] > 0} {error [listOfErrors "" $errors]}
    set ::config $conf
}

proc feedFile {soundFile} {
    arrangeWait $soundFile.flag
    dict for {host v} [dict get $::config speechkits] break
    if {![regexp {^(.+):(\d+)$} $host - host port]} {set port 80}
    ::log::log info "Распознаем $soundFile на $host:$port..."
    set pipe [run open [list | [dict get $::config asrclient] --key internal --server $host --port $port --ipv4 --silent $soundFile] r]
    set textH [run open $soundFile.tmp w]
    if {!$::dryRun} {		# guard for eof on fake channel
	while {![eof $pipe]} {
	    set line [gets $pipe]
	    if {[regexp {^from } $line] || [regexp {^\s*$} $line]} {} else {run puts $textH $line}
	}
    }
    run close $textH
    run close $pipe
    run file rename -force -- $soundFile.tmp $soundFile.text
    finishedWith $soundFile.flag
    catch {run file delete -- $soundFile}
    ::log::log info "$soundFile -> $soundFile.text"
}

proc runQueue {} {
    set flagFiles [glob -nocomplain -directory [file normalize [dict get $::config queue]] *.flag]
    foreach flagFile [lsort $flagFiles] {
	if {[needWaitMore $flagFile]} continue
	set soundFile [file rootname $flagFile]
	if {![file exists $soundFile]} {
	    catch {run file delete -- $flagFile}
	    continue
	}
	if [catch {feedFile $soundFile} err dbg] {
	    debugStackTrace $dbg
	    ::log::log error "Проблема при распознавании $soundFile:\n$err"
	    catch {run file delete -- $soundFile.tmp}
	}
    }
    after 500 runQueue
}

proc needWaitMore {flagFile} {
    if {[file mtime $flagFile] > [clock seconds]} {return 1}
    if {![info exists ::flagWait($flagFile)]} {return 0}
    if {$::flagWait($flagFile) > [clock seconds]} {return 1}
    return 0
}

proc arrangeWait {flagFile} {
    set nextAttempt [expr [clock seconds] + 1800]
    if {[catch {run file mtime $flagFile $nextAttempt}]} {
	set ::flagWait($flagFile) $nextAttempt
    }
}

proc finishedWith {flagFile} {
    run file delete -- $flagFile
    if {[info exists ::flagWait($flagFile)]} {unset ::flagWait($flagFile)}
}

proc cleanFlagWait {} {
    if {[array exists ::flagWait]} {
	set now [clock seconds]
	foreach k [array names ::flagWait] {
	    if {$::flagWait($k) < $now} {unset ::flagWait($k)}
	}
    }
    after 60000 cleanFlagWait
}

main
