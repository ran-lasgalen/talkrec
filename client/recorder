#!/bin/sh
# -*- tcl -*- \
exec tclsh "$0" ${1+"$@"}

proc debug {message} {puts stderr $message}

proc acceptConn {sock addr port} {
    fconfigure $sock -blocking 0 -buffering line
    fileevent $sock readable [list serveCmd $sock]
}

proc cleanupIncompleteCommandCache {} {
    set now [clock seconds]
    set staleTime [expr $now - 5]
    foreach chan [array names ::incompleteCommandStart] {
	if {$::incompleteCommandStart($chan) < $staleTime} {
	    unset -nocomplain ::incompleteCommand($chan)
	    unset -nocomplain ::incompleteCommandStart($chan)
	}
    }
    return $now
}

proc getCommand {chan} {
    set now [cleanupIncompleteCommandCache]
    append ::incompleteCommand($chan) [gets $chan]
    set cmd $::incompleteCommand($chan)
    if {[info complete $cmd] && $cmd ne ""} {
	unset -nocomplain ::incompleteCommand($chan)
	unset -nocomplain ::incompleteCommandStart($chan)
	return $cmd
    } else {
	if {[eof $chan]} {
	    close $chan
	} else {
	    checkVar ::incompleteCommandStart($chan) $now
	}
	return ""
    }
}

proc checkNames {arr names} {
    upvar $arr a
    set errors {}
    foreach name $names {
	if {![info exists a($name)]} {lappend errors need:$name}
    }
    return $errors
}

proc checkRE {var name re} {
    upvar $var v
    if {![info exists v]} {
	return [list need:$name]
    } elseif {[regexp "^$re\$" $v]} {
	return {}
    } else {
	return [list "re:$name!$re"]
    }
}

proc tellState {chan replyId} {puts $chan [concat $replyId [array get ::recordState] [array get ::config siteId] [array get ::config headset]]}

proc tellErrors {chan replyId errors} {puts $chan [list $replyId errors $errors]}

proc serveCmd {chan} {
    set cmdWithId [getCommand $chan]
    if {$cmdWithId eq ""} return
    if {![regexp {^\s*(\d+)(.*)} $cmdWithId - replyId cmd]} {
	set cmd $cmdWithId
	set replyId 0
    }
    switch -regexp -matchvar matches $cmd {
	{^\s*state\M} {tellState $chan $replyId}
	{^internals$} {puts $chan [list $replyId ::record [array get ::record]]}
	{^\s*set\s+(\S.*)} {
	    set params [lindex $matches 1]
	    updateArray ::recordState {name employeeId} $params
	    updateArray ::config {siteId} $params
	    tellState $chan $replyId
	}
	{^\s*clearError\s*$} {
	    if {$::recordState(state) eq "error"} {
		set ::recordState(state) noDevice
		unset ::recordState(errorMessage)
		if {[catch getJabraDev msg]} {setErrorState $msg}
		tellState $chan $replyId
	    }
	}
	{^\s*stop\s*$} {
	    stopRecord
	    tellState $chan $replyId
	}
	{^\s*start\s+(\S.*)} {
	    set errors {}
	    if {$::recordState(state) == "ready"} {
		# запуск записи возможен только из состояния "готов"
		set params [lindex $matches 1]
		array set pa $params
		updateArray ::recordState {name employeeId} $params
		set rsErrors [checkNames ::recordState {name employeeId}]
		set cfErrors [checkNames ::config {siteId headset}]
		set tmErrors [checkRE ::recordState(time) time {\d+}]
		if {![info exists pa(time)]} {
		    set tmErrors [list "need:time"]
		} elseif {$pa(time) <= 0} {
		    set tmErrors [list "cond:time>0"]
		} else {
		    if {$pa(time) > 600} {set pa(time) 600}
		    set ::record(length) $pa(time)
		    set tmErrors {}
		}
		set errors [concat $rsErrors $cfErrors $tmErrors]
		if {[llength $errors]} {
		    tellErrors $chan $replyId $errors
		} else {
		    startRecord
		    tellState $chan $replyId
		}
	    } else {
		tellErrors $chan $replyId [list "wrongState:$::recordState(state)"]]
	    }
	}
	default {
	    tellErrors $chan $replyId [list "Unrecognized command: $cmd"]]
	}
    }   
}

proc getJabraDev {} {
    set ::record(soundSystem) $::config(soundSystem)
    unset -nocomplain ::record(device)
    switch $::record(soundSystem) {
	pulse {
	    set pipe [open "| pactl list short sources"]
	    while {![eof $pipe]} {
		if {[regexp {^\d+\s+(\S+)} [gets $pipe] dummy dev] && [regexp $::config(deviceRE) $dev]} {
		    close $pipe
		    set ::record(device) $dev
		    return
		}
	    }
	    close $pipe
	    error noDevice
	}
	fake {set ::record(device) $::config(fakeRecord)}
	default {error "Unsupported sound system $::record(soundSystem)"}
    }
}

proc doStartChunk {} {
    switch $::record(soundSystem) {
	pulse {
	    set ::record(pid) [exec parecord --rate=16000 --channels=1 --device=$::record(device) $::record(file) 2> $::record(file).stderr &]
	}
	fake {}
	default {error "Unsupported sound system $::record(soundSystem)"}
    }
    puts "Started record to $::record(file)"
}

proc doStartRecord {} {
    # TODO make pre-record settings according to soundSystem
    doStartChunk
}

proc doStopRecord {} {
    switch $::record(soundSystem) {
	pulse {
	    catch {exec kill $::record(pid)}
	    if {[file exists $::record(file).stderr] && [file size $::record(file).stderr] == 0} {
		file delete $::record(file).stderr
	    }
	}
	fake {
	    if {[catch {file copy -- $::record(device) $::record(file)} err]} {catch {
		set fh [open $::record(file).stderr w]
		puts $fh $err
		close $fh
	    }}
	}
    }
    if {[file exists $::record(file)]} {
	set fh [open $::record(file).meta.tmp w]
	puts $fh "employeeId=$::recordState(employeeId)"
	puts $fh "name=$::recordState(name)"
	close $fh
	file rename $::record(file).meta.tmp $::record(file).meta
	puts "Finished $::record(file)"
    } else {
	puts "Error recording to $::record(file)"
    }
}

proc setErrorState {msg} {
    unset -nocomplain ::recordState(recordTime)
    if {$msg eq "noDevice"} {
	set ::recordState(state) noDevice
    } else {
	set ::recordState(errorMessage) $msg
	set ::recordState(state) error
    }
}

proc genRecordFileName {now} {
    set t [clock format $now -format "%Y%m%d_%H%M%S"]
    return [format "%s_%s_%d_%s.wav" $t $::config(siteId) $::config(headset) $::record(id)]
}

proc startRecord {} {
    set now [clock seconds]
    set ::record(id) [format "%08x" $now]
    set ::record(file) [genRecordFileName $now]
    if {[catch doStartRecord errMsg]} {
	setErrorState $errMsg
    } else {
	set now [clock seconds]
	set ::record(chunkTime) $now
	set ::record(startTime) $now
	set ::recordState(recordTime) 0
	set ::recordState(state) recording
    }
}

proc checkRecordingProcess {} {
    switch $::record(soundSystem) {
	pulse {
	    if {[catch {exec kill -0 $::record(pid)}]} {
		set fh [open $::record(file).stderr]
		set errMsg [read $fh]
		close $fh
		file delete -- $::record(file).stderr $::record(file)
		setErrorState $errMsg
		unset ::record
	    }
	}
	fake {}
    }
}

proc stopRecord {} {
    doStopRecord
    unset ::recordState(recordTime)
    if {[catch getJabraDev msg]} {setErrorState $msg} else {set ::recordState(state) ready}
}

proc startNextChunk {} {
    doStopRecord
    set now [clock seconds]
    set ::record(file) [genRecordFileName $now]
    if {[catch doStartChunk errMsg]} {
	setErrorState $errMsg
    } else {
	set ::record(chunkTime) $now
    }
}

proc checkVar {var val} {
    upvar $var v
    if {![info exists v]} {set v $val}
}

proc checkRecordState {} {
    if {![info exists ::recordState(state)]} {set ::recordState(state) noDevice}
    switch $::recordState(state) {
	noDevice {
	    if {[catch getJabraDev msg]} {
		setErrorState $msg
	    } else {
		set ::recordState(state) ready
	    }
	}
	ready {
	    if {[catch getJabraDev msg]} {setErrorState $msg}
	}
	recording {
	    set now [clock seconds]
	    checkVar ::record(startTime) $now 
	    checkVar ::record(chunkTime) $now
	    set ::recordState(recordTime) [expr $now - $::record(startTime)]
	    if {$::recordState(recordTime) >= $::record(length)} {
		stopRecord
	    } elseif {$now - $::record(chunkTime) >= $::recordChunkLength} {
		startNextChunk
	    } else {
		checkRecordingProcess
	    }
	}
    }
    after 500 checkRecordState
}

proc updateArray {arr allowNames pairList} {
    upvar $arr a
    foreach {name value} $pairList {
	if {[lsearch -exact $allowNames $name] >= 0} {
	    set a($name) $value
	}
    }
}

proc readConfig {file} {
    array set ::config {port 17119 workdir . soundSystem pulse deviceRE input.usb-GN_Netcom_A_S_Jabra_PRO_9460}
    source $file
    if {![info exists ::config(headset)]} {error "Не указан номер гарнитуры (::config(headset))"}
    file mkdir $::config(workdir)
    cd $::config(workdir)
}

proc main {} {
    array set ::recordState {}
    set configFile [lindex $::argv 0]
    if {![file readable $configFile]} {set configFile ~/.config/talkrec/recorder.tcl}
    if {[catch {readConfig $configFile} err]} {
	puts stderr $err
	exit 2
    }
    set ::recordChunkLength 600
    checkRecordState
    socket -server acceptConn $::config(port)
    puts "Listen for connections on TCP port $::config(port)"
    vwait forever
}

main
