#!/usr/bin/tclsh

set libtcldir [file join [file dirname [file normalize [info script]]] libtcl]
source [file join $libtcldir common.tcl]
package require yaml

proc acceptConn {sock addr port} {
    fconfigure $sock -blocking 0 -buffering line
    fileevent $sock readable [list serveCmd $sock]
}

proc cleanupIncompleteCommandCache {} {
    set now [clock seconds]
    set staleTime [expr $now - 5]
    foreach chan [array names ::incompleteCommandStart] {
	if {$::incompleteCommandStart($chan) < $staleTime} {
	    unset -nocomplain ::incompleteCommand($chan)
	    unset -nocomplain ::incompleteCommandStart($chan)
	}
    }
    return $now
}

proc getCommand {chan} {
    set now [cleanupIncompleteCommandCache]
    append ::incompleteCommand($chan) [gets $chan]
    set cmd $::incompleteCommand($chan)
    if {[info complete $cmd] && $cmd ne ""} {
	unset -nocomplain ::incompleteCommand($chan)
	unset -nocomplain ::incompleteCommandStart($chan)
	return $cmd
    } else {
	if {[eof $chan]} {
	    close $chan
	} else {
	    checkVar ::incompleteCommandStart($chan) $now
	}
	return ""
    }
}

proc tellState {chan replyId} {
    set dct [dict merge [array get ::recordState] [array get ::intent] [list mode $::mode] [dict filter $::config key headset]]
    puts $chan [concat $replyId $dct]
}

proc tellErrors {chan replyId errors} {puts $chan [list $replyId errors $errors]}

proc serveCmd {chan} {
    set cmdWithId [getCommand $chan]
    if {$cmdWithId eq ""} return
    if {![regexp {^\s*(\d+)(.*)} $cmdWithId - replyId cmd]} {
	set cmd $cmdWithId
	set replyId 0
    }
    try {
	switch -regexp -matchvar matches $cmd {
	    {^\s*state\M} {tellState $chan $replyId}
	    {^internals$} {puts $chan [list $replyId ::record [array get ::record] ::config $::config]}
	    {^\s*clearError\s*$} {
		if {$::recordState(state) eq "error"} {
		    set ::recordState(state) restart
		    unset -nocomplain ::recordState(errorMessage)
		    checkRecordState
		    tellState $chan $replyId
		}
	    }
	    {^\s*stop\s*$} {
		stopRecord
		checkRecordState
		tellState $chan $replyId
	    }
	    {^\s*end\s*$} {
		array set ::intent {mode end}
		stopRecord
		checkRecordState
		tellState $chan $replyId
	    }
	    {^\s*start\s+(\S.*)} {
		if {[catch {dict merge \
				[dict filter $::config key siteId auto] \
				[dict create maxTime $::maxRecordTime] \
				[lindex $matches 1]} params dbg]} {
		    debugStackTrace $dbg
		    tellErrors $chan $replyId [list $params]
		} else {
		    if {![catch {dict get $params mode} mode] && $mode in {forbid end}} {
			set errors {}
		    } else {
			set errors [checkDict $params {
			    {mode "режим записи: auto, manual, forbid или end" {^(auto|manual|forbid|en)$}}
			    {employeeId "идентификатор сотрудника" {^\d+$}}
			    {siteId "идентификатор салона" {^\d+$}}
			    {maxTime "максимальное время записи" {^\d+$}}
			}]
		    }
		    if {$mode ni {forbid end} && [catch {checkAutoParams $params} err]} {lappend $errors $err}
		    if {[llength $errors] > 0} {
			tellErrors $chan $replyId $errors
		    } else {
			set maxTime [dict get $params maxTime]
			if {$maxTime <= 0 || $maxTime > $::maxRecordTime} {
			    dict set params maxTime $::maxRecordTime
			}
			array set ::intent $params
			stopRecord
			checkRecordState
			tellState $chan $replyId
		    }
		}
	    }
	    default {
		tellErrors $chan $replyId [list "Неизвестная команда: $cmd"]
	    }
	}
    } on error {err dbg} {
	debugStackTrace $dbg
	tellErrors $chan $replyId [list "Ошибка разработчика: $err"]
    }
}

# На выходе ::record(soundSystem) из конфига
# и либо ::record(device), либо error noDevice, либо текстуальная ошиюка
# setErrorState по noDevice выставляет состояние noDevice, а не error
proc getJabraDev {} {
    set ::record(soundSystem) [dict get $::config soundSystem]
    set deviceRE [dict get $::config deviceRE]
    unset -nocomplain ::record(device)
    switch $::record(soundSystem) {
	pulse {
	    set pipe [open "| pactl list short sources"]
	    while {![eof $pipe]} {
		if {[regexp {^\d+\s+(\S+)} [gets $pipe] - dev] && [regexp $deviceRE $dev]} {
		    close $pipe
		    set ::record(device) $dev
		    return
		}
	    }
	    close $pipe
	    error noDevice
	}
	fake {
	    # Наличие файла мы здесь не проверяем — пригодится потом для теста
	    # ошибки записи
	    set ::record(device) [dict get $::config fakeRecord]
	}
	default {error "Unsupported sound system $::record(soundSystem)"}
    }
}

# На выходе, если не ошибка, обязательно валидный пайп в ::record(pipe)
proc doStartRecord {} {
    file delete -- $::record(file) $::record(file).stderr
    switch $::record(soundSystem) {
	pulse {
	    set params [list trim 0 $::intent(maxTime)]
	    if {$::intent(mode) eq "auto"} {
		array set param $::intent(auto)
		switch $param(autoMode) {
		    silence {
			set params [list silence 1 $param(aboveDuration) $param(aboveLevel) 1 $param(belowDuration) $param(belowLevel)]
		    }
		}
	    }
	    set pipeCmd [list | sox -r 16000 -b 16 -c 1 -t s16 "|parec --rate=16000 --channels=1 --device=$::record(device)" $::record(file) {*}$params 2> $::record(file).stderr]
	    #set ::record(pid) [run exec parecord --rate=16000 --channels=1 --device=$::record(device) $::record(file) 2> $::record(file).stderr &]
	    set ::record(pipe) [run open $pipeCmd r]
	    if {$::dryRun} {
		set ::record(pipe) [open sleep $::intent(maxTime)]
	    }
	}
	fake {
	    if {![regexp {after(\d+)} $::record(device) - delay]} {set delay 6}
	    after [expr {$delay * 1000}] [list run file copy -- $::record(device) $::record(file)]
	    set ::record(pipe) [open sleep $::intent(maxTime)]
	}
	default {error "Unsupported sound system $::record(soundSystem)"}
    }
    fconfigure $::record(pipe) -blocking 0
    fileevent $::record(pipe) readable [list watchRecorder [array get ::intent] $::record(pipe)]
    safelog {info "Started record in $::intent(mode) mode"}
}

# Главным образом обработчик завершения
proc watchRecorder {intentList pipe} {
    # в stdout ничего интересного от программы не ждем
    read $pipe
    if {[eof $pipe]} {
	set resultFile [file join [file normalize [dict get $::config workdir]] [genRecordFileName $intentList]]
	if {[catch {close $pipe} err] && $::recordState(state) ne "stopping"} {
	    # если stopping, то ошибка ожидаемая, ибо kill
	    # а тут реальная ошибка
	    # stderr оставляем для разборок
	    set msg "Error while recording"
	    if {[file exists $::record(file)] &&
		[file size $::record(file)] > 0 &&
		![catch {file rename -- $::record(file) $resultFile}]} {
		append msg " to $resultFile"
	    }
	    catch {
		set fh [open $::record(file).stderr a]
		puts $fh $err
		close $fh
		file rename -- $::record(file).stderr $resultFile.stderr
	    }
	    if {[file exists $resultFile.stderr]} {
		append msg "\nsee $resultFile.stderr for possible debugging help"
	    }
	    safelog {error $msg}
	} else {
	    # успешное завершение
	    catch {run file delete -- $::record(file).stderr}
	    if {[file exists $::record(file)] &&
		[file size $::record(file)] > 100} {
		try {
		    run file rename -- $::record(file) $resultFile
		    array set intent $intentList
		    set autoParams [dict create]
		    if {$intent(mode) eq "auto"} {catch {set autoParams $intent(auto)}}
		    createFileViaTmp $resultFile.yaml \
			[::yaml::dict2yaml \
			     [dict merge \
				  [dict filter $intentList key employeeId name siteId] \
				  $autoParams]]
		    safelog {info "Finished $resultFile"}
		} on error {err dbg} {
		    debugStackTrace $dbg
		    safelog {error "Error saving information for $resultFile:\n  $err"}
		}
	    } else {
		safelog {info "$::record(file) too small, ignoring"}
	    }
	}
	unset -nocomplain ::record ::recordState(recordTime)
	set ::recordState(state) restart
	checkRecordState
    }
}

proc setErrorState {msg} {
    unset -nocomplain ::recordState(recordTime) ::recordState(errorMessage)
    if {$msg eq "noDevice"} {
	set ::recordState(state) noDevice
    } else {
	set ::recordState(errorMessage) $msg
	set ::recordState(state) error
    }
}

proc genRecordFileName {intentList} {
    array set intent $intentList
    if {[info exists ::record(startTime)]} {
	set startTime $::record(startTime)
    } else {
	set startTime [clock seconds]
    }
    set t [clock format $startTime -format "%Y%m%d_%H%M%S"]
    format "%s_%s_%d_%d.wav" $t $::intent(siteId) [dict get $::config headset] $startTime
}

proc doIntended {} {
    set ::mode $::intent(mode)
    if {$::intent(mode) eq "end"} {
	safelog {notice "Exit requested"}
	exit
    }
    if {$::recordState(state) ne "ready" ||
	$::intent(mode) eq "forbid"} return
    set ::record(file) [file join [file normalize [dict get $::config workdir]] current.wav]
    if {[catch doStartRecord err]} {
	setErrorState $err
    } else {
	switch $::intent(mode) {
	    auto {set ::recordState(state) silence}
	    manual {
		markStartRecord
		set ::intent(mode) auto
	    }
	    default {
		# should not be here
		safelog {error "recording started in unsupported mode '$::intent(mode)', interpreted as manual"}
		markStartRecord
	    }
	}
    }
}

proc stopRecord {} {
    if {[info exists ::record(pipe)]} {
	# Если запись идет фактически, на формальное состояние не смотрим
	set ::recordState(state) stopping
	unset -nocomplain ::recordState(error)
	if {[catch {
	    set pids [pid $::record(pipe)]
	    if {[llength $pids] > 0} {run! exec kill -INT {*}$pids}
	} err dbg]} {
	    set ::recordState(state) restart
	    debugStackTrace $dbg
	    safelog {error "Stopping recording: $err"}
	}
    } elseif {$::recordState(state) in {recording silence}} {
	safelog {error "Stopping recording: process pipe doesn't exist"}
	set ::recordState(state) restart
    }
}

proc checkVar {var val} {
    upvar $var v
    if {![info exists v]} {set v $val}
}

proc checkRecordStateLoop {} {
    checkRecordState
    after 500 checkRecordStateLoop
}

proc checkRecordState {} {
    if {![info exists ::recordState(state)]} {set ::recordState(state) restart}
    switch $::recordState(state) {
	restart -
	ready -
	noDevice {
	    if {[catch getJabraDev msg]} {
		setErrorState $msg
	    } else {
		set ::recordState(state) ready
		doIntended
	    }
	}
	silence {
	    if {[info exists ::record(file)] &&
		[file exists $::record(file)] &&
		[file size $::record(file)] > 100} markStartRecord
	}
	recording {
	    set now [clock seconds]
	    checkVar ::record(startTime) $now
	    checkVar ::intent(maxTime) $::maxRecordTime
	    set ::recordState(recordTime) [expr $now - $::record(startTime)]
	    if {$::recordState(recordTime) >= $::intent(maxTime)} stopRecord
	}
    }
}

proc markStartRecord {} {
    set ::record(startTime) [clock seconds]
    set ::recordState(recordTime) 0
    set ::recordState(state) recording
}

set ::autoModeChecks [dict create \
			  silence {
			      {aboveDuration "время звука в начале" {^\d+(\.\d*+)?$}}
			      {belowDuration "время тишины в конце" {^\d+(\.\d*+)?$}}
			      {aboveLevel "нижний порог звука" {^\d+(\.\d*+)?[d%]$}}
			      {belowLevel "верхний порог тишины" {^\d+(\.\d*+)?[d%]$}}
			  }]

proc checkAutoParams {dct} {
    if {[catch {dict get $dct auto} auto]} {error "отсутствует блок параметров автоматического режима (ключ auto)"}
    if {[catch {dict get $auto autoMode} mode]} {error "в блоке параметров (ключ auto) отсутствует автоматический режим (ключ autoMode)"}
    if {[catch {dict get $::autoModeChecks $mode} checks]} {error "неизвестный автоматический режим $mode"}
    set errors [checkDict $auto $checks]
    if {[llength $errors]} {
	error [listOfErrors "в блоке параметров (ключ auto):" $errors]
    }
}

proc checkWorkHours {} {
    if {![info exists ::lastAutoForbid]} {set ::lastAutoForbid 0}
    set now [clock seconds]
    foreach {h m} [clock format $now -format "%H %M"] break
    if {[catch {dict get $::config workHours} workHours]} {set workHours "10 21"}
    foreach {startH endH} $workHours break
    if {$h < $startH || $h >= $endH} {
	if {$now - $::lastAutoForbid >= 3600 && $::mode ne "forbid"} {
	    safelog {info "Off-hours, recording forbidden automatically"}
	    array set ::intent {mode forbid}
	    stopRecord
	    set ::lastAutoForbid $now
	}
    }
}

proc checkWorkHoursLoop {} {
    catchDbg checkWorkHours
    after 60000 checkWorkHoursLoop
}

proc readConfig {file} {
    set defaultConfig [dict create recorderPort 17119 workdir . soundSystem pulse deviceRE input.usb-GN_Netcom_A_S_Jabra_PRO_9460 auto [dict create autoMode silence aboveDuration 0.5 aboveLevel 0.1% belowDuration 10.0 belowLevel 2%] workHours "10 21"]
    set readConfig [readDict $file]
    set config [dict merge $defaultConfig $readConfig]
    set errors [checkDict $config {
	{headset "номер гарнитуры" {^\d+$}}
    }]
    if {[catch {checkAutoParams $config} err]} {lappend $errors $err}
    switch [dict get $config soundSystem] {
	pulse {
	    if {![dict exists $config deviceRE]} {
		lappend errors "Не указано регулярное выражение устройства (ключ deviceRE)"
	    }
	}
	fake {
	    if {![dict exists $config fakeRecord]} {
		lappend errors "Не указан файл-источник записи (ключ fakeRecord)"
	    } else {
		dict set config fakeRecord [file normalize [dict get $config fakeRecord]]
	    }
	}
    }
    foreach reKey {deviceRE} {
	if {[catch {dict get $config $reKey} re]} continue
	if {[catch {regexp $re ""}]} {
	    lappend errors "'$re' (ключ $reKey) не является регулярным выражением"
	}
    }
    if {[llength $errors] > 0} {error [listOfErrors "Ошибки конфигурации" $errors]}
    set ::config $config
    file mkdir [dict get $::config workdir]
}

proc main {} {
    getOptions [configDictFile recorder] {}
    array set ::recordState {state restart}
    if {[catch {readConfig $::opt(-config)} err dbg]} {
	debugStackTrace $dbg
	::log::log error "Ошибка чтения конфигурации из $::opt(-config):\n$err"
	exit 2
    }
    set ::maxRecordTime 300
    set ::mode forbid
    array set ::intent [list \
			    mode forbid \
			    maxTime $::maxRecordTime \
			    {*}[dict filter $::config key siteId auto]]
    checkWorkHoursLoop
    checkRecordStateLoop
    socket -server acceptConn [dict get $::config recorderPort]
    ::log::log notice "Слушаю на порту TCP [dict get $::config recorderPort]"
    vwait forever
}

main
