#!/bin/sh
# -*- tcl -*- \
exec tclsh "$0"  ${1+"$@"}

package require Tcl 8.2
package require cmdline

proc acceptConn {sock addr port} {
    fconfigure $sock -blocking 0 -buffering line
    puts $sock "Hello $addr:$port"
    fileevent $sock readable [list serveCmd $sock]
}

proc cleanupIncompleteCommandCache {} {
    set now [clock seconds]
    set staleTime [expr $now - 5]
    foreach chan [array names ::incompleteCommandStart] {
	if {$::incompleteCommandStart($chan) < $staleTime} {
	    unset -nocomplain ::incompleteCommand($chan)
	    unset -nocomplain ::incompleteCommandStart($chan)
	}
    }
    return $now
}

proc getCommand {chan} {
    set now [cleanupIncompleteCommandCache]
    append ::incompleteCommand($chan) [gets $chan]
    set cmd $::incompleteCommand($chan)
    if {[info complete $cmd] && $cmd ne ""} {
	unset -nocomplain ::incompleteCommand($chan)
	unset -nocomplain ::incompleteCommandStart($chan)
	return $cmd
    } else {
	if {[eof $chan]} {
	    close $chan
	} else {
	    checkVar ::incompleteCommandStart($chan) $now
	}
	return ""
    }
}

proc checkNames {arr names} {
    upvar $arr a
    set errors {}
    foreach name $names {
	if {![info exists a($name)]} {lappend errors need:$name}
    }
    return $errors
}

proc checkRE {var name re} {
    upvar $var v
    if {![info exists v]} {
	return [list need:$name]
    } elseif {[regexp "^$re\$" $v]} {
	return {}
    } else {
	return [list "re:$name!$re"]
    }
}

proc tellState {chan} {puts $chan [concat [array get ::recordState] [array get ::config siteId] [array get ::config headset]]}

proc tellErrors {chan errors} {puts $chan [list errors $errors]}

proc serveCmd {chan} {
    set cmd [getCommand $chan]
    if {$cmd eq ""} return
    switch -regexp -matchvar matches $cmd {
	{^\s*state\M} {tellState $chan}
	{^\s*set\s+(\S.*)} {
	    set params [lindex $matches 1]
	    updateArray ::recordState {name employeeId} $params
	    updateArray ::config {siteId} $params
	    tellState $chan
	}
	{^\s*start\s+(\S.*)} {
	    set errors {}
	    if {$::recordState(state) == "ready"} {
		# запуск записи возможен только из состояния "готов"
		set params [lindex $matches 1]
		array set pa $params
		updateArray ::recordState {name employeeId} $params
		set rsErrors [checkNames ::recordState {name employeeId}]
		set cfErrors [checkNames ::config {siteId headset}]
		set tmErrors [checkRE ::recordState(time) time {\d+}]
		if {![info exists pa(time)]} {
		    set tmErrors [list "need:time"]
		} elseif {$pa(time) <= 0} {
		    set tmErrors [list "cond:time>0"]
		} else {
		    set ::recordLength $pa(time)
		    set tmErrors {}
		}
		set errors [concat $rsErrors $cfErrors $tmErrors]
		if {[llength $errors]} {
		    tellErrors $chan $errors
		} else {
		    startRecord
		    tellState $chan
		}
	    } else {
		tellErrors $chan [list "wrongState:$::recordState(state)"]]
	    }
	}
	default {
	    tellErrors $chan [list "Unrecognized command: $cmd"]]
	}
    }   
}

proc getJabraDev {} {return "jabra"}

proc doStartRecord {} {
    # TODO really start record
}

proc doStopRecord {} {
    # TODO really stop record and queue file
}

proc setErrorState {msg} {
    unset -nocomplain ::recordState(recordTime)
    if {$msg eq "noDevice"} {
	set ::recordState(state) noDevice
    } else {
	set ::recordState(errorMessage) $msg
	set ::recordState(state) error
    }
}

proc startRecord {} {
    if {[catch doStartRecord errMsg]} {
	setErrorState errMsg
    } else {
	set now [clock seconds]
	set ::recordChunkTime $now
	set ::recordStartTime $now
	set ::recordState(recordTime) 0
	set ::recordState(state) recording
    }
}

proc stopRecord {} {
    doStopRecord
    array unset ::recordState recordTime
    if {[getJabraDev] eq ""} {
	set ::recordState(state) noDevice
    } else {
	set ::recordState(state) ready
    }
}

proc startNextChunk {} {
    doStopRecord
    if {[catch doStartRecord errMsg]} {
	setErrorState errMsg
    } else {
	set ::recordChunkTime [clock seconds]
    }
}

proc checkVar {var val} {
    upvar $var v
    if {![info exists v]} {set v $val}
}

proc checkRecordState {} {
    if {![info exists ::recordState(state)]} {set ::recordState(state) noDevice}
    switch $::recordState(state) {
	noDevice {
	    if {[getJabraDev] ne ""} {set ::recordState(state) ready}
	}
	ready {
	    if {[getJabraDev] eq ""} {set ::recordState(state) noDevice}
	}
	recording {
	    set now [clock seconds]
	    checkVar ::recordStartTime $now 
	    checkVar ::recordChunkTime $now
	    set ::recordState(recordTime) [expr $now - $::recordStartTime]
	    if {$::recordState(recordTime) >= $::recordLength} {
		stopRecord
	    } elseif {$now - $::recordChunkTime >= $::recordChunkLength} {
		startNextChunk
	    }
	}
    }
    after 500 checkRecordState
}

proc updateArray {arr allowNames pairList} {
    upvar $arr a
    foreach {name value} $pairList {
	if {[lsearch -exact $allowNames $name] >= 0} {
	    set a($name) $value
	}
    }
}

proc main {} {
    array set ::recordState {}
    set optDesc {
	{headset.arg "" "номер гарнитуры, обязательный"}
	{site.arg "" "идентификатор салона"}
	{port.arg 17119 "слушать на этом порту TCP"}
    }
    set usageString "options"
    if {[catch {::cmdline::getoptions ::argv $optDesc $usageString} res]} {
	puts stderr $res
	exit 1
    }
    array set ::opt $res
    if {$::opt(headset) > 0} {set ::config(headset) $::opt(headset)}
    if {![info exists ::config(headset)]} {
	puts stderr "Headset number is not specified.\n[::cmdline::usage $optDesc $usageString]"
	exit 2
    }
    set ::recordChunkLength 180
    checkRecordState
    puts "Listening on port $::opt(port)"
    socket -server acceptConn $::opt(port)
    vwait forever
}

main
