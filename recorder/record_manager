#!/usr/bin/wish

set libtcldir [file join [file dirname [file normalize [info script]]] libtcl]
source [file join $libtcldir common.tcl]
package require yaml
package require BWidget

set ::notTaken —

proc main {} {
    getOptions [configFile record_manager.yaml] {}
    try {
	# Ключ - имя, значение - employeeId
	array set ::employee [::yaml::yaml2dict -file [configFile employees.yaml]]
	set ::config [readConfig $::opt(config)]
    } on error {err dbg} {
	debugStackTrace $dbg
	puts stderr $err
	exit 2
    }
    array set ::availableHeadsets {}
    array set ::headsetsInUse {}
    set ::defaultBoldFont [boldVersionOfFont TkDefaultFont]
    createMainFrame
    foreach peer [dict get $::config recorders] {
	if {[string first : $peer] < 0} {set peer [string cat $peer :17119]}
	set ::onConnect($peer) [list connectedToRecorder $peer]
	set ::onDisconnect($peer) [list disconnectedFromRecorder $peer]
	after idle [list startConnectionLoop $peer]
    }
}

proc readConfig {configFile} {
    set conf [::yaml::yaml2dict -file $configFile]
    set errors {}
    if {![dict exists $conf recorders]} {lappend errors "не указаны адреса устройств записи (recorders)"}
    if {![dict exists $conf siteId]} {lappend errors "не указан идентификатор салона (siteId)"}
    if {[llength $errors] > 0} {error [listOfErrors "Ошибки конфигурации" $errors]}
    return $conf
}

proc debug {message} {puts stderr $message}

proc setIfExists {checkVar setVar} {
    upvar $checkVar cv
    set ie [info exists cv]
    if {$ie} {
	upvar $setVar v
	set v $cv
    }
    return $ie
}

proc startConnectionLoop {peer} {
    if {![regexp {(.*)[: ](\d+)$} $peer - host port]} {return "Не умею соединяться с $peer"}
    if {![info exists ::onConnect($peer)]} {return "Не знаю, что делать после соединения с $peer"}
    if {[info exists ::peerChan($peer)]} {return "Соединение с $peer уже существует"}
    if {[catch {socket -async $host $port} sock]} {
	after 1000 [list startConnectionLoop $peer]
	return "Проблема соединения с $peer (TCP порт $port на $host): $sock"
    }
    set ::peerChan($peer) $sock
    set ::chanPeer($sock) $peer
    set aid [after 1000 [list cleanAndReconnect $peer]]
    fileevent $sock writable [list justConnected $peer $aid]
}

proc cleanAndReconnect {peer} {
    if {[setIfExists ::onDisconnect($peer) onDisconnect]} {catch $onDisconnect}
    if {[setIfExists ::peerChan($peer) chan]} {
	catch {close $chan}
	cleanChanCaches $chan
	unset -nocomplain ::peerChan($peer) ::chanPeer($chan)
	if {[info exists ::onConnect($peer)]} {
	    after 1000 [list startConnectionLoop $peer]
	}
    }
}

proc cleanChan {chan} {
    if {[setIfExists ::chanPeer($chan) peer]} {
	cleanAndReconnect $peer
    } else {
	catch {close $chan}
	cleanChanCaches $chan
    }
}

proc cleanChanCaches {chan} {
    unset -nocomplain ::incompleteCommand($chan) ::incompleteCommandStart($chan)
}

proc justConnected {peer timeoutId} {
    after cancel $timeoutId
    if {![setIfExists ::peerChan($peer) sock]} {cleanAndReconnect $peer; return}
    if {[fconfigure $sock -error] ne ""} {cleanAndReconnect $peer; return}
    fileevent $sock writable ""
    fconfigure $sock -blocking 0 -buffering line
    if {![setIfExists ::onConnect($peer) script]} {cleanAndReconnect $peer; return}
    after idle $script
}

proc connectedToRecorder {peer} {
    if {[setIfExists ::peerChan($peer) chan]} {
	fileevent $chan readable [list handleReply $chan]
    }
    after idle [list requestState $peer]
}

proc disconnectedFromRecorder {peer} {
    foreach {headset p} [array get ::availableHeadsets] {
	if {$p eq $peer} {
	    unset -nocomplain ::headsetState($headset)
	    updateWidgetsForHeadset $headset
	    break
	}
    }
}

proc chanPeer {chan} {
    if {[info exists ::chanPeer($chan)]} {
	return $::chanPeer($chan)
    } else {
	return $chan
    }
}

# TODO be more careful on possible filling buffers
proc sendRequest {chan request} {
    set peer [chanPeer $chan]
    ::log::log debug "$peer <- $request"
    if {[catch {puts $chan $request} err]} {
	::log::log error "Ошибка отправки запроса к $peer: $err"
	cleanChan $chan
	return 0
    }
    if {[fconfigure $chan -error] ne ""} {
	::log::log error "Ошибка в соединении с $peer: [fconfigure $chan -error]"
	cleanChan $chan
	return 0
    }
    return 1
}

proc requestState {peer} {
    if {![setIfExists ::peerChan($peer) chan]} {cleanAndReconnect $peer; return}
    if {[sendRequest $chan [list [nextCommandId] state]]} {
	after 500 [list requestState $peer]
    }
}

proc handleReply {chan} {
    setIfExists ::chanPeer($chan) peer
    set replyWithId [getReply $chan]
    if {$replyWithId eq ""} return
    ::log::log debug "$peer -> $replyWithId"
    if {![regexp {^\s*(\d+)\s+(\S.*)} $replyWithId - replyId reply]} {
	set reply $replyWithId
	set replyId 0
    }
    array set state $reply
    if {[setIfExists state(headset) headset]} {
	if {[info exists peer]} {
	    set ::availableHeadsets($headset) $peer
	} else {
	    unset ::availableHeadsets($headset)
	}
	set ::headsetState($headset) [array get state]
	updateWidgetsForHeadset $headset
    }
}

proc getReply {chan} {
    set now [cleanupIncompleteCommandCache]
    append ::incompleteCommand($chan) [gets $chan]
    set cmd $::incompleteCommand($chan)
    if {[info complete $cmd] && $cmd ne ""} {
	unset -nocomplain ::incompleteCommand($chan) ::incompleteCommandStart($chan)
	return $cmd
    } else {
	if {[eof $chan]} {
	    cleanChan $chan
	} else {
	    checkVar ::incompleteCommandStart($chan) $now
	}
	return ""
    }
}

proc checkVar {var val} {
    upvar $var v
    if {![info exists v]} {set v $val}
}

proc cleanupIncompleteCommandCache {} {
    set now [clock seconds]
    set staleTime [expr $now - 5]
    foreach chan [array names ::incompleteCommandStart] {
	if {$::incompleteCommandStart($chan) < $staleTime} {
	    unset -nocomplain ::incompleteCommand($chan)
	    unset -nocomplain ::incompleteCommandStart($chan)
	}
    }
    return $now
}

proc nextCommandId {} {
    incr ::nextCommandId
    format "%010d" $::nextCommandId
}

proc boldVersionOfFont {font} {
    array set font_attrs [font actual $font]
    set font_attrs(-weight) bold
    if {[catch {font create {*}[array get font_attrs]} res]} {
	puts stderr "boldVersionOfFont: $res"
	return $font
    } else {
	return $res
    }
}

proc createMainFrame {} {
    set ::mainWindow .
    wm title $::mainWindow "Управление записью"
    wm iconname $::mainWindow "Управление записью"
    wm attributes $::mainWindow -fullscreen 1
    grid anchor $::mainWindow center
    set mainFrame [ScrolledWindow .mainFrame]
    grid $mainFrame -sticky nswe
    array set i [grid info $mainFrame]
    grid columnconfigure $i(-in) $i(-column) -weight 1
    grid rowconfigure $i(-in) $i(-row) -weight 1
    set sf [ScrollableFrame $mainFrame.sf]
    $mainFrame setwidget $sf
    set ::employeeFrame [$sf getframe]
    createEmployeesTable $::employeeFrame
    grid [button $::mainWindow.exit -command exit -text {Завершить работу}]
}

proc freeHeadsets {} {
    set res {}
    foreach hs [array names ::availableHeadsets] {
	if {![info exists ::headsetsInUse(h_$hs)]} {lappend res $hs}
    }
    return [lsort -integer $res]
}

proc takeHeadset {employeeId headset} {
    leaveHeadset $employeeId
    if {[info exists ::availableHeadsets($headset)]} {
	set ::headsetsInUse(e_$employeeId) $headset
	set ::headsetsInUse(h_$headset) $employeeId
	updateWidgetsForEmployee $employeeId $headset
	startRecordOnHeadset $headset {} auto
	return true
    } else {
	return false
    }
}

proc startRecordOnHeadset {headset button mode} {
    if {$button ne ""} {$button configure -state disabled -command {}}
    if {![setIfExists ::availableHeadsets($headset) peer]} return
    if {![setIfExists ::peerChan($peer) chan]} {cleanAndReconnect $peer; return}
    if {![setIfExists ::headsetsInUse(h_$headset) employeeId]} return
    foreach {name id} [array get ::employee] {
	if {$id == $employeeId} {
	    set request [list [nextCommandId] start \
			     siteId [dict get $::config siteId] \
			     employeeId $id name $name \
			     mode $mode]
	    if {[sendRequest $chan $request]} {
		#debug "Sent request to $chan: $request"
	    }
	    break
	}
    }
}

proc stopRecordOnHeadset {headset button} {
    if {$button ne ""} {$button configure -state disabled -command {}}
    if {![setIfExists ::availableHeadsets($headset) peer]} return
    if {![setIfExists ::peerChan($peer) chan]} {cleanAndReconnect $peer; return}
    set request [list [nextCommandId] stop]
    if {[sendRequest $chan $request]} {
	#debug "Sent request to $chan: $request"
    }
}

proc forbidRecordOnHeadset {headset button} {
    if {$button ne ""} {$button configure -state disabled -command {}}
    if {![setIfExists ::availableHeadsets($headset) peer]} return
    if {![setIfExists ::peerChan($peer) chan]} {cleanAndReconnect $peer; return}
    set request [list [nextCommandId] start mode forbid]
    if {[sendRequest $chan $request]} {
	#debug "Sent request to $chan: $request"
    }
}

proc formatRecordTime {time} {
    set h [expr {$time / 3600}]
    set m [expr {$time % 3600 / 60}]
    set s [expr {$time % 60}]
    if {$h > 0} {
	format "%d:%02d:%02d" $h $m $s
    } else {
	format "%d:%02d" $m $s
    }
}

proc updateWidgetsForEmployee {employeeId headset} {
    if {![dict exists $::employeeControls $employeeId]} return
    dict with ::employeeControls $employeeId {
	set state noHeadset
	set mode auto
	set time 0
	safelog {debug [list headset $headset state [array get ::headsetState]]} 
	if {[info exists ::headsetState($headset)]} {
	    # Если есть состояние станции с этой гарнитурой, то данные из него
	    array set st $::headsetState($headset)
	    safelog {debug [list st [array get st]]}
	    if {[info exists st(state)]} {set state $st(state)} {set state error}
	    if {[info exists st(mode)]} {set mode $st(mode)}
	    if {[info exists st(recordTime)]} {set time $st(recordTime)}
	} else {
	    safelog {debug [list NO $headset IN [array get ::headsetState]]}
	    # Если состояния станции с этой гарнитурой нет, а гарнитура есть, это другая проблема
	    if {$headset ne ""} {set state headsetAbsent}
	}
	# Состояние кнопки запрещения для всех состояний, когда гарнитура
	# есть (их большинство), зависит от mode. Для остальных перекроем.
	if {$mode eq "forbid"} {
	    $forbidButton configure -background {light green} -state normal -text "Разрешить" -command [list startRecordOnHeadset $headset $forbidButton auto]
	} else {
	    $forbidButton configure -background yellow -state normal -text "Запретить" -command [list forbidRecordOnHeadset $headset $forbidButton]
	}
	switch $state {
	    noHeadset {
		$stateLabel configure -text "Гарнитура не взята"
		$recordButton configure -background gray85 -state disabled -text "" -command {}
		$forbidButton configure -background gray85 -state disabled -text "" -command {}
	    }
	    headsetAbsent {
		$stateLabel configure -text "Гарнитура не подключена"
		$recordButton configure -background gray85 -state disabled -text "" -command {}
		$forbidButton configure -background gray85 -state disabled -text "" -command {}
	    }
	    restart {
		$stateLabel configure -text "Подготовка"
		$recordButton configure -background gray85 -state disabled -text "Ждем..." - command {}
	    }
	    ready {
		$stateLabel configure -text "Готовность"
		$recordButton configure -background {light green} -state normal -text "Запустить" -command [list startRecordOnHeadset $headset $recordButton manual]
	    }
	    noDevice {
		$stateLabel configure -text "Гарнитура не подключена"
		$recordButton configure -background red -state disabled -text "" -command {}
	    }
	    silence {
		$stateLabel configure -text "Тишина"
		$recordButton configure -background {light green} -state normal -text "Запустить" -command [list startRecordOnHeadset $headset $recordButton manual]
	    }
	    recording {
		$stateLabel configure -text "Запись [formatRecordTime $time]"
		$recordButton configure -background yellow -state normal -text "Отрезать" -command [list stopRecordOnHeadset $headset $recordButton]
	    }
	    stopping {
		$stateLabel configure -text "Остановка..."
		$recordButton configure -background gray85 -state disabled -text "Ждем..." -command {}
	    }
	    error {
		$stateLabel configure -text "Ошибка"
		$recordButton configure -background red -state normal -text "Сбросить" -command [list clearErrorOnHeadset $headset $recordButton]
	    }
	    default {
		# В том числе error
		$stateLabel configure -text "Ошибка"
		$recordButton configure -background red -state disabled -text "" -command {}
	    }
	}
	if {$mode eq "forbid"} {
	    # mode forbid возможно только если станция есть и гарнитуру видит,
	    # поэтому тут не смотрим на то, есть ли гарнитура
	    $recordButton configure -background red -state disabled -text "Запрещена" -command {}
	}
    }
}
	    
proc updateWidgetsForHeadset {headset} {
    if {![info exists ::headsetsInUse(h_$headset)]} return
    set employeeId $::headsetsInUse(h_$headset)
    updateWidgetsForEmployee $employeeId $headset
}

proc leaveHeadset {employeeId} {
    if {[info exists ::headsetsInUse(e_$employeeId)]} {
	set hs $::headsetsInUse(e_$employeeId)
	forbidRecordOnHeadset $hs {}
	unset -nocomplain ::headsetsInUse(h_$hs) ::headsetsInUse(e_$employeeId)
	updateWidgetsForEmployee $employeeId {}
    }
}

proc createEmployeesTable container {
    proc setAvailableHeadsets {combobox} {
	$combobox configure -values [concat $::notTaken [freeHeadsets]]
    }
    proc selectHeadsetFor {employeeId selector} {
	set headset [$selector get]
	if {![takeHeadset $employeeId $headset]} {
	    $selector set $::notTaken
	}
    }
    grid anchor $container center
    set ::employeeControls [dict create]
    set hName [label $container.hName -font $::defaultBoldFont -text Имя]
    set hHeadset [label $container.hHeadset -font $::defaultBoldFont -text Гарнитура]
    set hRecord [label $container.hRecord -font $::defaultBoldFont -text Запись]
    grid configure $hName $hHeadset $hRecord
    grid configure $hName -sticky w
    foreach name [lsort -dictionary [array names ::employee]] {
	set id $::employee($name)
	set nameLabel [label $container.nm$id -text $name]
	set headsetSelector [ttk::combobox $container.hs$id -justify center -state readonly -width 3 -values $::notTaken]
	$headsetSelector configure -postcommand [list setAvailableHeadsets $headsetSelector]
	$headsetSelector set $::notTaken
	bind $headsetSelector <<ComboboxSelected>> [list selectHeadsetFor $id $headsetSelector]
	set stateLabel [label $container.st$id -text "Гарнитура не взята" -width 24 -justify right] 
	set recordButton [button $container.rb$id -state disabled -text "" -width 15]
	set forbidButton [button $container.fb$id -state normal -text "" -width 10]
	grid configure $nameLabel $headsetSelector $stateLabel $recordButton $forbidButton
	grid configure $nameLabel -sticky w
	grid configure $headsetSelector -sticky we
	grid configure $stateLabel -sticky e
	grid configure $recordButton -sticky we
	grid configure $forbidButton -sticky we
	dict set ::employeeControls $id [dict create nameLabel $nameLabel headsetSelector $headsetSelector stateLabel $stateLabel recordButton $recordButton forbidButton $forbidButton]
    }
    grid columnconfigure $container all -pad 8
    grid rowconfigure $container all -pad 8
}

main
