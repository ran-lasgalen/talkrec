#!/usr/bin/wish

set libtcldir [file join [file dirname [file normalize [info script]]] libtcl]
source [file join $libtcldir common.tcl]
package require yaml
package require BWidget

set ::notTaken —

proc main {} {
    getOptions [configDictFile record_manager] {}
    try {
	# Ключ - имя, значение - employeeId
	array set ::employee [readDict [configFile employees]]
	set ::config [readConfig $::opt(-config)]
    } on error {err dbg} {
	debugStackTrace $dbg
	puts stderr $err
	exit 2
    }
    array set ::availableHeadsets {}
    array set ::headsetsInUse {}
    set ::defaultBoldFont [boldVersionOfFont TkDefaultFont]
    createMainFrame
    foreach peer [dict get $::config recorders] {
	if {[string first : $peer] < 0} {set peer [string cat $peer :17119]}
	set ::onConnect($peer) [list connectedToRecorder $peer]
	set ::onDisconnect($peer) [list disconnectedFromRecorder $peer]
	after idle [list startConnectionLoop $peer]
    }
}

proc readConfig {configFile} {
    set conf [readDict $configFile]
    set errors {}
    if {![dict exists $conf recorders]} {lappend errors "не указаны адреса устройств записи (recorders)"}
    if {![dict exists $conf siteId]} {lappend errors "не указан идентификатор салона (siteId)"}
    if {[llength $errors] > 0} {error [listOfErrors "Ошибки конфигурации" $errors]}
    return $conf
}

proc debug {message} {puts stderr $message}

proc setIfExists {checkVar setVar} {
    upvar $checkVar cv
    set ie [info exists cv]
    if {$ie} {
	upvar $setVar v
	set v $cv
    }
    return $ie
}

proc startConnectionLoop {peer} {
    if {![regexp {(.*)[: ](\d+)$} $peer - host port]} {return "Не умею соединяться с $peer"}
    if {![info exists ::onConnect($peer)]} {return "Не знаю, что делать после соединения с $peer"}
    if {[info exists ::peerChan($peer)]} {return "Соединение с $peer уже существует"}
    if {[catch {socket -async $host $port} sock]} {
	after 1000 [list startConnectionLoop $peer]
	return "Проблема соединения с $peer (TCP порт $port на $host): $sock"
    }
    set ::peerChan($peer) $sock
    set ::chanPeer($sock) $peer
    set aid [after 1000 [list cleanAndReconnect $peer]]
    fileevent $sock writable [list justConnected $peer $aid]
}

proc cleanAndReconnect {peer} {
    if {[setIfExists ::onDisconnect($peer) onDisconnect]} {catch $onDisconnect}
    if {[setIfExists ::peerChan($peer) chan]} {
	catch {close $chan}
	cleanChanCaches $chan
	unset -nocomplain ::peerChan($peer) ::chanPeer($chan)
	if {[info exists ::onConnect($peer)]} {
	    after 1000 [list startConnectionLoop $peer]
	}
    }
}

proc cleanChan {chan} {
    if {[setIfExists ::chanPeer($chan) peer]} {
	cleanAndReconnect $peer
    } else {
	catch {close $chan}
	cleanChanCaches $chan
    }
}

proc cleanChanCaches {chan} {
    unset -nocomplain ::incompleteCommand($chan) ::incompleteCommandStart($chan)
}

proc justConnected {peer timeoutId} {
    after cancel $timeoutId
    if {![setIfExists ::peerChan($peer) sock]} {cleanAndReconnect $peer; return}
    if {[fconfigure $sock -error] ne ""} {cleanAndReconnect $peer; return}
    fileevent $sock writable ""
    fconfigure $sock -blocking 0 -buffering line
    if {![setIfExists ::onConnect($peer) script]} {cleanAndReconnect $peer; return}
    after idle $script
}

proc connectedToRecorder {peer} {
    if {[setIfExists ::peerChan($peer) chan]} {
	fileevent $chan readable [list handleReply $chan]
    }
    after idle [list requestState $peer]
}

proc disconnectedFromRecorder {peer} {
    foreach {headset p} [array get ::availableHeadsets] {
	if {$p eq $peer} {
	    unset ::availableHeadsets($headset)
	    unset -nocomplain ::headsetState($headset)
	    updateWidgetsForHeadset $headset
	    break
	}
    }
}

proc chanPeer {chan} {
    if {[info exists ::chanPeer($chan)]} {
	return $::chanPeer($chan)
    } else {
	return $chan
    }
}

# TODO be more careful on possible filling buffers
proc sendRequest {chan request} {
    set peer [chanPeer $chan]
    safelog {debug "$peer <- $request"}
    if {[catch {puts $chan $request} err]} {
	safelog {error "Ошибка отправки запроса к $peer: $err"}
	cleanChan $chan
	return 0
    }
    if {[fconfigure $chan -error] ne ""} {
	safelog {error "Ошибка в соединении с $peer: [fconfigure $chan -error]"}
	cleanChan $chan
	return 0
    }
    return 1
}

proc requestState {peer} {
    if {![setIfExists ::peerChan($peer) chan]} {cleanAndReconnect $peer; return}
    if {[sendRequest $chan [simpleDictToJSON [dict create msgId [nextCommandId] req state]]]} {
	after 500 [list requestState $peer]
    }
}

proc handleReply {chan} {
    if {[chanHasError $chan err] || [eof $chan]} {cleanChan $chan; return}
    if {![setIfExists ::chanPeer($chan) peer]} {
	safelog {error "Oops! no peer for $chan"}
	cleanChan $chan
	return
    }
    set line [gets $chan]
    if {[regexp {^\s*$} $line]} return
    safelog {debug "$peer -> $line"}
    if {[catch {lindex [parseRecorderReply $line] 1} reply]} {
	safelog {error "Проблема с запросом от $peer: $reply"}
	return
    }
    array set state $reply
    if {[setIfExists state(headset) headset]} {
	# если в ответе есть номер гарнитуры
	# записываем, на каком она хосте
	if {[info exists peer]} {
	    set ::availableHeadsets($headset) $peer
	} else {
	    unset ::availableHeadsets($headset)
	}
	set ::headsetState($headset) [array get state]
	if {[setIfExists state(employeeId) eid]} {
	    # станция в курсе, что кто-то взял
	    bindHeadsetToEmployee $headset $eid
	} else {
	    # сообщают, что гарнитура свободна
	    # если мы взяли гарнитуру, нам могут не мгновенно сообщить,
	    # что она наша, реагируем только через 2 секунды
	    if {![info exists ::headsetTakeIntent($headset)] ||
		[clock milliseconds] - $::headsetTakeIntent($headset) > 2000} {
		bindHeadsetToEmployee $headset {}
	    }
	}
    }
    if {[setIfExists state(errors) errors]} {
	# если errors - это точно нам, их отправляют в ответ на запрос
	setLastErrors $errors
    }
}

proc setLastErrors {errors} {
    set frame [lindex $::lastErrorsFrame 0]
    set text $frame.text
    $text replace 1.0 end [join $errors "\n"]
    $text see 1.0
    if {[llength [grid info $frame]] == 0} {grid {*}$::lastErrorsFrame}
}

proc showCurrentErrorForEmployee {employeeId} {
    if {![setIfExists ::headsetsInUse(e_$employeeId) headset]} return
    if {![setIfExists ::headsetState($headset) state]} return
    if {[dictGetOr "" $state state] eq "error"} {
	set errorMessage [dictGetOr "" $state errorMessage]
	if {$errorMessage ne ""} {setLastErrors [list $errorMessage]}
    }
}

proc reportBgError {msg dbg} {
    safelog {error [dictGetOr $msg $dbg -errorinfo]}
}

interp bgerror {} reportBgError

proc bindHeadsetToEmployee {headset eid} {
    # снимаем ожидание взятия, если оно было 
    unset -nocomplain ::headsetTakeIntent($headset)
    if {[setIfExists ::headsetsInUse(h_$headset) knownEid]} {
	# если мы думали, что гарниьура у другого, то нет, не у него
	if {$knownEid ne $eid} {unset -nocomplain ::headsetsInUse(e_$knownEid)}
	# для гарнитуры - следующим шагом
    }
    # фиксируем актуальное состояние in use
    if {$eid eq ""} {
	unset -nocomplain ::headsetsInUse(h_$headset)
    } else {
	set ::headsetsInUse(h_$headset) $eid
	set ::headsetsInUse(e_$eid) $headset
    }
    if {[info exists knownEid] && $knownEid ne $eid} {
	# если только что отобрали гарнитуру, отображаем у того сотрудника
	updateWidgetsForEmployee $knownEid {}
    }
    if {$eid ne ""} {
	# и если гарнитура сейчас у кого-то, отображаем у текущего владельца
	updateWidgetsForEmployee $eid $headset
    }
}

proc nextCommandId {} {
    incr ::nextCommandId
}

proc boldVersionOfFont {font} {
    array set font_attrs [font actual $font]
    set font_attrs(-weight) bold
    if {[catch {font create {*}[array get font_attrs]} res]} {
	puts stderr "boldVersionOfFont: $res"
	return $font
    } else {
	return $res
    }
}

proc createMainFrame {} {
    set ::mainWindow .
    wm title $::mainWindow "Управление записью"
    wm iconname $::mainWindow "Управление записью"
    #wm attributes $::mainWindow -fullscreen 1
    grid anchor $::mainWindow center
    set mainFrame [ScrolledWindow .mainFrame]
    grid $mainFrame -sticky nswe
    array set i [grid info $mainFrame]
    grid columnconfigure $i(-in) $i(-column) -weight 1
    grid rowconfigure $i(-in) $i(-row) -weight 1
    set sf [ScrollableFrame $mainFrame.sf]
    $mainFrame setwidget $sf
    set ::employeeFrame [$sf getframe]
    createEmployeesTable $::employeeFrame
    set lastErrorsFrame [createTextFrame .errors -width 80 -height 3 -foreground red]
    grid [button $lastErrorsFrame.hide -text "Скрыть" -command [list grid forget $lastErrorsFrame]] -column 2 -row 0 -rowspan 2 -sticky ns
    grid $lastErrorsFrame
    grid [button .endDay -command leaveAllHeadsets -text {Завершить рабочий день}]
    set ::showLogger 0
    grid [checkbutton .showLogger -text {Показывать окно технического отчета} -command showOrHideLogger]
    set loggerFrame [createTextFrame .logger -width 80 -height 12 -wrap none]
    set ::showDebuggingOutput $::opt(-debug)
    grid [checkbutton $loggerFrame.showDebuggingOutput -text {Показывать отладочный вывод} -command showOrHideDebug] -column 0 -row 2 -sticky w
    grid $loggerFrame
    set ::lastErrorsFrame [concat [list $lastErrorsFrame] [grid info $lastErrorsFrame]]
    grid forget $lastErrorsFrame
    set ::loggerFrame [concat [list $loggerFrame] [grid info $loggerFrame]]
    grid forget $loggerFrame
    ::log::lvCmdForall logToLogger
    foreach level [::log::levels] {
	set color [::log::lv2color $level]
	if {$color ne ""} {
	    $loggerFrame.text tag configure $level -foreground $color
	}
    }
}

proc showOrHideLogger {} {
    set lf [lindex $::loggerFrame 0]
    if {$::showLogger} {
	if {[llength [grid info $lf]] == 0} {grid {*}$::loggerFrame}
    } else {
	if {[llength [grid info $lf]] > 0} {grid forget $lf}
    }
}

proc showOrHideDebug {} {
    if {$::showDebuggingOutput} {
	::log::lvSuppress debug 0
    } else {
	::log::lvSuppress debug 1
    }
}

proc logToLogger {level line} {
    set text [lindex $::loggerFrame 0].text
    if {[$text count -lines 1.0 end] >= 1000} {
	$text delete 1.0 101.0
    }
    set vis [$text dlineinfo {end-1c linestart}]
    $text insert end "\n$line" $level
    if {$vis ne ""} {$text see {end-1c linestart}}
}

proc createTextFrame {path args} {
    set frame [frame $path]
    set text [text $path.text -yscrollcommand [list $path.ybar set] -xscrollcommand [list $path.xbar set] {*}$args]
    set xbar [scrollbar $path.xbar -orient horizontal -command [list $path.text xview]]
    set ybar [scrollbar $path.ybar -orient vertical -command [list $path.text yview]]
    grid $text $ybar
    grid $xbar
    grid configure $text -sticky nwse
    grid configure $ybar -sticky ns
    grid configure $xbar -sticky we
    grid columnconfigure $frame $text -weight 1
    grid rowconfigure $frame $text -weight 1
    return $frame
}

proc freeHeadsets {} {
    set res {}
    foreach hs [array names ::availableHeadsets] {
	if {![info exists ::headsetsInUse(h_$hs)]} {lappend res $hs}
    }
    return [lsort -integer $res]
}

proc takeHeadset {employeeId headset} {
    leaveHeadset $employeeId
    if {[info exists ::availableHeadsets($headset)]} {
	set ::headsetTakeIntent($headset) [clock milliseconds]
	set ::headsetsInUse(e_$employeeId) $headset
	set ::headsetsInUse(h_$headset) $employeeId
	updateWidgetsForEmployee $employeeId $headset
	startRecordOnHeadset $headset {} auto
	return true
    } else {
	return false
    }
}

proc employeeToRequest {employeeId} {
    foreach {name id} [array get ::employee] {
	if {$id == $employeeId} {
	    return [dict create employeeId $id name $name]
	}
    }
    return {}
}

proc headsetEmployeeToRequest {headset} {
    if {[setIfExists ::headsetsInUse(h_$headset) employeeId]} {
	employeeToRequest $employeeId
    } else {
	return {}
    }
}

proc siteToRequest {} {dict create siteId [dict get $::config siteId]}

proc startRecordOnHeadset {headset button mode} {
    if {$button ne ""} {$button configure -state disabled -command {}}
    if {![setIfExists ::availableHeadsets($headset) peer]} return
    if {![setIfExists ::peerChan($peer) chan]} {cleanAndReconnect $peer; return}
    set employeeData [headsetEmployeeToRequest $headset]
    if {[llength $employeeData] == 0} return
    set request [dict merge \
		     [dict create msgId [nextCommandId] req start mode $mode] \
		     [siteToRequest] $employeeData]
    if {[sendRequest $chan [simpleDictToJSON $request]]} {
	#debug "Sent request to $chan: $request"
    }
}

proc stopRecordOnHeadset {headset button} {
    if {$button ne ""} {$button configure -state disabled -command {}}
    if {![setIfExists ::availableHeadsets($headset) peer]} return
    if {![setIfExists ::peerChan($peer) chan]} {cleanAndReconnect $peer; return}
    set request [dict create msgId [nextCommandId] req stop]
    if {[sendRequest $chan [simpleDictToJSON $request]]} {
	#debug "Sent request to $chan: $request"
    }
}

proc forbidRecordOnHeadset {headset button} {
    if {$button ne ""} {$button configure -state disabled -command {}}
    if {![setIfExists ::availableHeadsets($headset) peer]} return
    if {![setIfExists ::peerChan($peer) chan]} {cleanAndReconnect $peer; return}
    set request [dict merge \
		     [dict create msgId [nextCommandId] req start mode forbid] \
		     [siteToRequest] [headsetEmployeeToRequest $headset]]
    if {[sendRequest $chan [simpleDictToJSON $request]]} {
	#debug "Sent request to $chan: $request"
    }
}

proc clearErrorOnHeadset {headset button} {
    if {$button ne ""} {$button configure -state disabled -command {}}
    if {![setIfExists ::availableHeadsets($headset) peer]} return
    if {![setIfExists ::peerChan($peer) chan]} {cleanAndReconnect $peer; return}
    set request [dict create msgId [nextCommandId] req clearError]
    if {[sendRequest $chan [simpleDictToJSON $request]]} {
	#debug "Sent request to $chan: $request"
    }
}

proc formatRecordTime {time} {
    set h [expr {$time / 3600}]
    set m [expr {$time % 3600 / 60}]
    set s [expr {$time % 60}]
    if {$h > 0} {
	format "%d:%02d:%02d" $h $m $s
    } else {
	format "%d:%02d" $m $s
    }
}

proc updateWidgetsForEmployee {employeeId headset} {
    if {![dict exists $::employeeControls $employeeId]} return
    dict with ::employeeControls $employeeId {
	if {$headset eq ""} {$headsetSelector set $::notTaken} else {$headsetSelector set $headset}
	set state noHeadset
	set mode auto
	set time 0
	if {[info exists ::headsetState($headset)]} {
	    # Если есть состояние станции с этой гарнитурой, то данные из него
	    array set st $::headsetState($headset)
	    if {[info exists st(state)]} {set state $st(state)} {set state error}
	    if {[info exists st(mode)]} {set mode $st(mode)}
	    if {[info exists st(recordTime)]} {set time $st(recordTime)}
	} else {
	    # Если состояния станции с этой гарнитурой нет, а гарнитура есть, это другая проблема
	    if {$headset ne ""} {set state headsetAbsent}
	}
	# Состояние кнопки запрещения для всех состояний, когда гарнитура
	# есть (их большинство), зависит от mode. Для остальных перекроем.
	if {$mode eq "forbid"} {
	    $forbidButton configure -background {light green} -state normal -text "Разрешить" -command [list startRecordOnHeadset $headset $forbidButton auto]
	} else {
	    $forbidButton configure -background yellow -state normal -text "Запретить" -command [list forbidRecordOnHeadset $headset $forbidButton]
	}
	switch $state {
	    noHeadset {
		$stateLabel configure -text "Гарнитура не взята"
		$recordButton configure -background gray85 -state disabled -text "" -command {}
		$forbidButton configure -background gray85 -state disabled -text "" -command {}
	    }
	    headsetAbsent {
		$stateLabel configure -text "Гарнитура не подключена"
		$recordButton configure -background gray85 -state disabled -text "" -command {}
		$forbidButton configure -background gray85 -state disabled -text "" -command {}
	    }
	    restart {
		$stateLabel configure -text "Подготовка"
		$recordButton configure -background gray85 -state disabled -text "Ждем..." - command {}
	    }
	    ready {
		$stateLabel configure -text "Готовность"
		$recordButton configure -background {light green} -state normal -text "Запустить" -command [list startRecordOnHeadset $headset $recordButton manual]
	    }
	    noDevice {
		$stateLabel configure -text "Гарнитура не подключена"
		$recordButton configure -background red -state disabled -text "" -command {}
	    }
	    silence {
		$stateLabel configure -text "Тишина"
		$recordButton configure -background {light green} -state normal -text "Запустить" -command [list startRecordOnHeadset $headset $recordButton manual]
	    }
	    recording {
		$stateLabel configure -text "Запись [formatRecordTime $time]"
		$recordButton configure -background yellow -state normal -text "Отрезать" -command [list stopRecordOnHeadset $headset $recordButton]
	    }
	    stopping {
		$stateLabel configure -text "Остановка..."
		$recordButton configure -background gray85 -state disabled -text "Ждем..." -command {}
	    }
	    error {
		$stateLabel configure -text "Ошибка"
		$recordButton configure -background red -state normal -text "Сбросить" -command [list clearErrorOnHeadset $headset $recordButton]
	    }
	    default {
		$stateLabel configure -text "Ошибка"
		$recordButton configure -background red -state disabled -text "" -command {}
	    }
	}
	if {$mode eq "forbid" && $state ne "error"} {
	    # mode forbid возможно только если станция есть и гарнитуру видит,
	    # поэтому тут не смотрим на то, есть ли гарнитура
	    $recordButton configure -background red -state disabled -text "Запрещена" -command {}
	}
    }
}

proc updateWidgetsForHeadset {headset} {
    if {[setIfExists ::headsetsInUse(h_$headset) employeeId]} {
	updateWidgetsForEmployee $employeeId $headset
    }
}

proc leaveHeadset {employeeId} {
    if {[setIfExists ::headsetsInUse(e_$employeeId) hs]} {
	unset -nocomplain ::headsetsInUse(h_$hs) ::headsetsInUse(e_$employeeId)
	forbidRecordOnHeadset $hs {}
	updateWidgetsForEmployee $employeeId {}
    }
}

proc leaveAllHeadsets {} {
    foreach chan [array names ::chanPeer] {
	sendRequest $chan [simpleDictToJSON [dict create msgId [nextCommandId] req start mode forbid]]
    }
    foreach headset [array names ::availableHeadsets] {
	if {[info exists ::headsetsInUse(h_$headset)]} {
	    set eid $::headsetsInUse(h_$headset)
	    unset -nocomplain ::headsetsInUse(e_$eid) ::headsetsInUse(h_$headset)
	    updateWidgetsForEmployee $eid {}
	}
    }
}

proc createEmployeesTable container {
    proc setAvailableHeadsets {combobox} {
	$combobox configure -values [concat $::notTaken [freeHeadsets]]
    }
    proc selectHeadsetFor {employeeId selector} {
	set headset [$selector get]
	if {![takeHeadset $employeeId $headset]} {
	    $selector set $::notTaken
	}
    }
    grid anchor $container center
    set ::employeeControls [dict create]
    set hName [label $container.hName -font $::defaultBoldFont -text Имя]
    set hHeadset [label $container.hHeadset -font $::defaultBoldFont -text Гарнитура]
    set hRecord [label $container.hRecord -font $::defaultBoldFont -text Запись]
    grid configure $hName $hHeadset $hRecord
    grid configure $hName -sticky w
    foreach name [lsort -dictionary [array names ::employee]] {
	set id $::employee($name)
	set nameLabel [label $container.nm$id -text $name]
	set headsetSelector [ttk::combobox $container.hs$id -justify center -state readonly -width 3 -values $::notTaken]
	$headsetSelector configure -postcommand [list setAvailableHeadsets $headsetSelector]
	$headsetSelector set $::notTaken
	bind $headsetSelector <<ComboboxSelected>> [list selectHeadsetFor $id $headsetSelector]
	set stateLabel [label $container.st$id -text "Гарнитура не взята" -width 24 -justify right]
	bind $stateLabel <Button-1> [list showCurrentErrorForEmployee $id]
	set recordButton [button $container.rb$id -state disabled -text "" -width 15]
	set forbidButton [button $container.fb$id -state normal -text "" -width 10]
	grid configure $nameLabel $headsetSelector $stateLabel $recordButton $forbidButton
	grid configure $nameLabel -sticky w
	grid configure $headsetSelector -sticky we
	grid configure $stateLabel -sticky e
	grid configure $recordButton -sticky we
	grid configure $forbidButton -sticky we
	dict set ::employeeControls $id [dict create nameLabel $nameLabel headsetSelector $headsetSelector stateLabel $stateLabel recordButton $recordButton forbidButton $forbidButton]
    }
    grid columnconfigure $container all -pad 8
    grid rowconfigure $container all -pad 8
}

main
